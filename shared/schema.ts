import {
  sqliteTable,
  text,
  integer,
  real,
} from "drizzle-orm/sqlite-core";
import { createInsertSchema } from "drizzle-zod";
import { relations } from "drizzle-orm";

// User storage table
export const users = sqliteTable("users", {
  id: text("id").primaryKey().notNull(),
  email: text("email").unique(),
  firstName: text("first_name"),
  lastName: text("last_name"),
  profileImageUrl: text("profile_image_url"),
  createdAt: integer("created_at", { mode: 'timestamp' }).$defaultFn(() => new Date()),
  updatedAt: integer("updated_at", { mode: 'timestamp' }).$defaultFn(() => new Date()),
});

// Keywords being monitored
export const keywords = sqliteTable("keywords", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: text("user_id").notNull().references(() => users.id),
  keyword: text("keyword").notNull(),
  isActive: integer("is_active", { mode: 'boolean' }).default(true),
  createdAt: integer("created_at", { mode: 'timestamp' }).$defaultFn(() => new Date()),
});

// Mentions found during crawling
export const mentions = sqliteTable("mentions", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  keywordId: integer("keyword_id").notNull().references(() => keywords.id),
  userId: text("user_id").notNull().references(() => users.id),
  title: text("title").notNull(),
  content: text("content").notNull(),
  url: text("url"),
  source: text("source").notNull(),
  sentiment: text("sentiment").notNull(), // 'positive', 'negative', 'neutral'
  sentimentScore: real("sentiment_score"),
  createdAt: integer("created_at", { mode: 'timestamp' }).$defaultFn(() => new Date()),
});

// Reports generated by the AI
export const reports = sqliteTable("reports", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: text("user_id").notNull().references(() => users.id),
  keywordId: integer("keyword_id").references(() => keywords.id),
  reportType: text("report_type").notNull().default('daily'),
  totalMentions: integer("total_mentions").default(0),
  positiveSentiment: real("positive_sentiment").default(0),
  negativeSentiment: real("negative_sentiment").default(0),
  neutralSentiment: real("neutral_sentiment").default(0),
  insights: text("insights"), // JSON string for AI-generated insights
  createdAt: integer("created_at", { mode: 'timestamp' }).$defaultFn(() => new Date()),
});

// Chat messages with AI
export const chatMessages = sqliteTable("chat_messages", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: text("user_id").notNull().references(() => users.id),
  message: text("message").notNull(),
  response: text("response").notNull(),
  context: text("context"), // JSON string for additional context
  createdAt: integer("created_at", { mode: 'timestamp' }).$defaultFn(() => new Date()),
});

// Scheduled reports
export const scheduledReports = sqliteTable("scheduled_reports", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: text("user_id").notNull().references(() => users.id),
  keywordId: integer("keyword_id").references(() => keywords.id),
  frequency: text("frequency").notNull(), // 'daily', 'weekly', 'monthly'
  isActive: integer("is_active", { mode: 'boolean' }).default(true),
  lastRun: integer("last_run", { mode: 'timestamp' }),
  nextRun: integer("next_run", { mode: 'timestamp' }).notNull(),
  emailNotification: integer("email_notification", { mode: 'boolean' }).default(false),
  createdAt: integer("created_at", { mode: 'timestamp' }).$defaultFn(() => new Date()),
});

// Relations
export const usersRelations = relations(users, ({ many }) => ({
  keywords: many(keywords),
  mentions: many(mentions),
  reports: many(reports),
  chatMessages: many(chatMessages),
  scheduledReports: many(scheduledReports),
}));

export const keywordsRelations = relations(keywords, ({ one, many }) => ({
  user: one(users, {
    fields: [keywords.userId],
    references: [users.id],
  }),
  mentions: many(mentions),
  reports: many(reports),
}));

export const mentionsRelations = relations(mentions, ({ one }) => ({
  keyword: one(keywords, {
    fields: [mentions.keywordId],
    references: [keywords.id],
  }),
  user: one(users, {
    fields: [mentions.userId],
    references: [users.id],
  }),
}));

export const reportsRelations = relations(reports, ({ one }) => ({
  user: one(users, {
    fields: [reports.userId],
    references: [users.id],
  }),
  keyword: one(keywords, {
    fields: [reports.keywordId],
    references: [keywords.id],
  }),
}));

export const chatMessagesRelations = relations(chatMessages, ({ one }) => ({
  user: one(users, {
    fields: [chatMessages.userId],
    references: [users.id],
  }),
}));

export const scheduledReportsRelations = relations(scheduledReports, ({ one }) => ({
  user: one(users, {
    fields: [scheduledReports.userId],
    references: [users.id],
  }),
  keyword: one(keywords, {
    fields: [scheduledReports.keywordId],
    references: [keywords.id],
  }),
}));

// Types for inserts and selects
export type User = typeof users.$inferSelect;
export type UpsertUser = typeof users.$inferInsert;

export type Keyword = typeof keywords.$inferSelect;
export type InsertKeyword = typeof keywords.$inferInsert;

export type Mention = typeof mentions.$inferSelect;
export type InsertMention = typeof mentions.$inferInsert;

export type Report = typeof reports.$inferSelect;
export type InsertReport = typeof reports.$inferInsert;

export type ChatMessage = typeof chatMessages.$inferSelect;
export type InsertChatMessage = typeof chatMessages.$inferInsert;

export type ScheduledReport = typeof scheduledReports.$inferSelect;
export type InsertScheduledReport = typeof scheduledReports.$inferInsert;

// Zod schemas
export const insertKeywordSchema = createInsertSchema(keywords);
export const insertMentionSchema = createInsertSchema(mentions);
export const insertReportSchema = createInsertSchema(reports);
export const insertChatMessageSchema = createInsertSchema(chatMessages);
export const insertScheduledReportSchema = createInsertSchema(scheduledReports);

// Utility type for analytics
export interface SentimentStats {
  keywordId?: number;
  keyword?: string;
  totalMentions: number;
  positiveMentions: number;
  negativeMentions: number;
  neutralMentions: number;
  averageSentiment: number;
  period: string;
}
